<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (c) 2010, NetEase.com,Inc. All rights reserved.

Author: Yang Bo (pop.atry@gmail.com)

Use, modification and distribution are subject to the "New BSD License"
as listed at <url: http://www.opensource.org/licenses/bsd-license.php >.
-->
<mx:WindowedApplication xmlns:mx="http://www.adobe.com/2006/mxml"
      layout="vertical" showStatusBar="false" title="录像管理器">
  <mx:Script><![CDATA[
    import com.netease.recording.server.Session;
    import mx.controls.Alert;
    import mx.collections.CursorBookmark;
    import mx.utils.URLUtil;
    import mx.controls.Button;
    import mx.collections.IViewCursor;
    import mx.collections.ArrayCollection;
    import flash.net.navigateToURL;

    private var replayURLPrefix:String;
    
    private var connection:LocalConnection;
    
    internal var cursor:IViewCursor;
    
    internal const readingStreams:Dictionary = new Dictionary();
    
    internal function stopRecord(session:Session):File
    {
      session.close();
      if (cursor.findAny(session))
      {
        cursor.remove();
      }
      else
      {
        throw new IllegalOperationError();
      }
      const file:File =
          File.applicationStorageDirectory.resolvePath(session.name);
      replays.addItem(file);
      return file;
    }
  ]]></mx:Script>
  
  <mx:ArrayCollection id="replays">
    <mx:sort>
      <mx:Sort>
        <mx:fields>
          <mx:SortField name="name"/>
        </mx:fields>
      </mx:Sort>
    </mx:sort>
  </mx:ArrayCollection>

  <mx:DataGrid id="replayGrid"
        width="100%" height="100%"
        allowMultipleSelection="true"
        dataProvider="{replays}">
    <mx:columns>
      <mx:DataGridColumn headerText="录像名称" dataField="name"/>
      <mx:DataGridColumn width="100" headerText="状态">
        <mx:labelFunction>{
          function(item:*, column:DataGridColumn):String
          {
            return item is Session ? "正在记录" : "可用";
          }
        }</mx:labelFunction>
      </mx:DataGridColumn>
    </mx:columns>
    <mx:copy>
      <![CDATA[
        Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT,
                                           replayGrid.selectedItems.map(
                                           function(item:*,
                                                    index:int,
                                                    array:Array):String
        {
          with (item)
          {
            return name;
          }
        }).join(','));
      ]]>
    </mx:copy>
  </mx:DataGrid>
  
  <mx:HBox>
    <mx:Button label="回放">
      <mx:enabled>{
        replayGrid.selectedItems.some(function(item:*,
                                               index:int,
                                               array:Array):Boolean
        {
          return item is File;
        })
      }</mx:enabled>
      <mx:click><![CDATA[
        const replayButton:Button = Button(event.target);
        if (replayButton.enabled)
        {
          for each (var item:Object in replayGrid.selectedItems)
          {
            const file:File = item as File;
            if (file)
            {
              navigateToURL(new URLRequest(replayURLPrefix + file.name),
                            String(Math.random()));
            }
          }
        }
      ]]></mx:click>
    </mx:Button>
    
    <mx:Button label="删除" enabled="{replayGrid.selectedItems.length > 0}">
      <mx:click><![CDATA[
        const stopButton:Button = Button(event.target);
        if (stopButton.enabled)
        {
          for each (var item:Object in replayGrid.selectedItems)
          {
            const session:Session = item as Session;
            if (session)
            {
              const file:File = stopRecord(session)
              file.deleteFile();
              if (cursor.findAny(file))
              {
                cursor.remove();
              }
              else
              {
                throw new IllegalOperationError();
              }
            }
            else
            {
              File(item).deleteFile();
              if (cursor.findAny(item))
              {
                cursor.remove();
              }
              else
              {
                throw new IllegalOperationError();
              }
            }
          }
        }
      ]]></mx:click>
    </mx:Button>
    
    <mx:Button label="刷新">
      <mx:click><![CDATA[
        for (cursor.seek(CursorBookmark.FIRST);
             !cursor.afterLast;)
        {
          const file:File = cursor.current as File;
          if (file)
          {
            if (!file.exists)
            {
              cursor.remove();
              continue;
            }
          }
          cursor.moveNext();
        }
        for each (var currentFile:File in
                  File.applicationStorageDirectory.getDirectoryListing())
        {
          if (!cursor.findAny(currentFile))
          {
            replays.addItem(currentFile);
          }
        }
      ]]></mx:click>
    </mx:Button>
    
  </mx:HBox>
  <mx:Component id="recordServiceFactory">
    <mx:Object>
      <mx:Script><![CDATA[
        import com.netease.recording.server.Session;
        public static const SEND_BYTES_LIMIT:uint = 32768;
        public function getReplay(name:String, dataConnectionName:String):void
        {
          const client:LocalConnection = new LocalConnection();
          if (!outerDocument.cursor.findAny({name:name}))
          {
            client.send(dataConnectionName, "notFound");
            return;
          }
          const file:File = File(outerDocument.cursor.current);
          const stream:FileStream = new FileStream();
          outerDocument.readingStreams[file] = stream;
          
          stream.addEventListener(ProgressEvent.PROGRESS,
                                  function(event:ProgressEvent):void
          {
            if (stream.bytesAvailable <= 0)
            {
              throw new IllegalOperationError();
            }
            const buffer:ByteArray = new ByteArray();
            stream.readBytes(buffer, 0, stream.bytesAvailable);
            client.send(dataConnectionName, "replayData", buffer);
            if (stream.position == file.size)
            {
              client.send(dataConnectionName, "replayEnd");
              delete outerDocument.readingStreams[file];
              IEventDispatcher(event.currentTarget).removeEventListener(
                  event.type, arguments.callee);
              stream.close();
            }
          });
          stream.readAhead = SEND_BYTES_LIMIT;
          stream.openAsync(file, FileMode.READ);
        }
        
        private static function dummyHandler(event:Event):void {}
        
        public function startRecord(name:String):void
        {
          const session:Session = new Session(name);
          session.timer.addEventListener(
              TimerEvent.TIMER,
              function(event:TimerEvent):void
          {
            try
            {
              const probeConnection:LocalConnection = new LocalConnection();
              probeConnection.send('_' + name, "probe");
              probeConnection.connect('_' + name);
              probeConnection.addEventListener(StatusEvent.STATUS, dummyHandler);
              probeConnection.close();
            }
            catch (e:ArgumentError)
            {
              // 客户端还没退出
              return;
            }
            outerDocument.stopRecord(session);
          });
          session.timer.start();
          outerDocument.replays.addItem(session);
        }
        public function record(name:String, data:XML):void
        {
          if (!outerDocument.cursor.findAny({name:name}))
          {
            // Not found
            return;
          }
          const session:Session = Session(outerDocument.cursor.current);
          XML.prettyPrinting = true;
          session.stream.writeUTFBytes(data.toXMLString());
          session.stream.writeUTFBytes("\n\n");
        }

        public function stopRecord(name:String):void
        {
          if (!outerDocument.cursor.findAny({name:name}))
          {
            // Not found
            return;
          }
          outerDocument.stopRecord(Session(outerDocument.cursor.remove()));
        }
        
      ]]></mx:Script>
    </mx:Object>
  </mx:Component>
  
  <mx:closing>
    <![CDATA[
      for (cursor.seek(CursorBookmark.FIRST);
           !cursor.afterLast;
           cursor.moveNext())
      {
        if (cursor.current is Session)
        {
          Alert.show("关闭录像管理器之前，必须先关闭正在录像的程序。");
          event.preventDefault();
        }
      }
    ]]>
  </mx:closing>
  
  <mx:invoke><![CDATA[
    if (event.arguments.length != 2)
    {
      throw new ArgumentError(
          "usage: adl RecordingServer-app.xml -- connectionName replay_url_prefix");
    }
    replayURLPrefix = event.arguments[1];
    const match:Array = replayURLPrefix.match(/^(file|https?):\/\/([^\/]*)(\/.*)?$/);
    if (!match) {
      throw new ArgumentError(
          "replay_url_prefix must start with file|http|https");
    }
    const domain:String = match[1] == "file" ? "localhost" : match[2];
    replays.source = File.applicationStorageDirectory.getDirectoryListing();
    cursor = replays.createCursor();
    connection = new LocalConnection();

    connection.allowDomain(domain);
    connection.client = recordServiceFactory.newInstance();
    connection.connect(event.arguments[0]);
  ]]></mx:invoke>
  
</mx:WindowedApplication>
